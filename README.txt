This is the submission for the take home project for the SSRL application from Loc Le. 
## General
The program contains two parts: encoding and decoding. Encoding take in a message and an image
directory. It then encode the message in an extended hamming(8,4) code format and stores in
at the end of the image from the image directory. Decoding reads any potential stored and encoded 
message in the same format from the imaage and output it out. 

## Dependencies
The program is compiled with gcc 6.3.0.
I didn't use any other libraries than the built in ones.
- stdio.h
- string.h
- stdlib.h

It is also compile on a Window machine. To be able to compile on Linux, you can make a few
modification Makefile file:
- EXT = out
- CLEAN = rm


## Compile and run
For encoding: 
- make encode
- ./encode.exe __MESSAGE_YOU__WANT__TO_HIDE ___IMG_PNG__DIRECTORY_

For decoding:
- make decode
- ./decode.exe 


## Extended Hamming(8,4) Code Encoding.
The Hamming(7,4) Code Encoding is a linear error-correcting code that encodes four bits of data. 
It does this using three redundant bits to measure the parity of the four data bits in specific
way that allows the program to detect and correct the specific bit that was flip in the case single
bit flip cases. The Hamming(8,4) extended code store an extra bit that measure the parity of the entire
output of the Hamming(7,4) byte[0]. Allowing me to detect(but not correct) multiple bit flips.
In this program, the resulting byte looks like:
p p_1 p_2 p_3 d_1 d_2 d_3 d_4
where:
- p is the extended parity bit
- p_1 to p_3 is the 7,4 hamming parity bits
- d_1 to d_4 is the data bits 

Note that this is different that the tradition Extended hamming(8,4) code format.
I will explain this further. The hamming(8,4) encoded byte is usually generated by
a generator matrix, the specific location of the single bit flip is generated using
a parity-check matrix. The matrices that I used for this project was borrowed from 
Asecuritysite hamming code calculator[2]. I used it because it resulted in a convenient
way for me to debug the code, and an easy way to read the data bits. However, the
website's generator matrix also resulted in a slightly modifed  version of the Hamming
code format. 

The reason why I chose this format was because:
- It is simple compares other Hamming Code format
- Allows for some bit flip correction.
- More efficient than storing 3 version of the message. 

However, the encoded message is still twice is large as the original 
message.


## Implementation and Storage
I stored the encoded message at the end of the image after the IEND chunk.
I specifically referenced the PNG file structure from libpng for how data is
stored in a PNG image [3]. 
Each character of the message is split into two parts, encoded in the Hamming code
format, then both are pushed into a short and written down on the image. 

To read the message from the image, I scan the image from the end for 
the IEND chunk and see if there is an message down there. It then decode
the message and print it out. 




Glossary:
[0] Hamming(7,4)
- https://en.wikipedia.org/wiki/Hamming(7,4)
[1] 3Blue1Brow: But what are Hamming codes? The origin of error correction
- https://www.youtube.com/watch?v=X8jsijhllIA&t=5s
[2] Asecuritysite hamming code calculator
- https://asecuritysite.com/calculators/hamming
[3] libpng PNG file structure
- http://www.libpng.org/pub/png/spec/1.2/PNG-Structure.html

 
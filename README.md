# Message PNG Encoder

This is the submission for the take home project for the SSRL application from Loc Le. 
## General
The program contains two parts: encoding and decoding. Encoding take in a message and an image directory. It then encode the message in an extended hamming(8,4) code format and stores in at the end of the image from the image directory. Decoding reads any potential stored and encoded message in the same format from the imaage and output it out. 

## Dependencies
The program is compiled with gcc 6.3.0.
I didn't use any other libraries than the built in ones.
- stdio.h
- stdbool.h
- string.h
- stdlib.h

It is compiled and tested on a Window machine. To be able to compile on Linux, you can make a few modifications to the Makefile file as follow:
- EXT = out
- CLEAN = rm


## Compile and run
For encoding: 
- make encode
- ./encode.exe __MESSAGE_YOU__WANT__TO_HIDE  __IMG_PNG__DIRECTORY___

For decoding:
- make decode
- ./decode.exe 


## Extended Hamming(8,4) Code Encoding.
The Hamming(7,4) Code Encoding is a linear error-correcting code that encodes four bits of data. It does this using three redundant bits to measure the parity of the four data bits in specific way that allows the program to detect and correct the specific bit that was flip in the case single bit flip cases. The Hamming(8,4) extended code store an extra bit that measure the parity of the entire
output of the Hamming(7,4) byte[0], allowing me to detect(but not correct) multiple bit flips.
In this program, the resulting byte looks like:
p p_1 p_2 p_3 d_1 d_2 d_3 d_4
where:
- p is the extended parity bit
- p_1 to p_3 is the 7,4 hamming parity bits
- d_1 to d_4 is the data bits 
- 8,4 extended bit as make it simple for me to store the byte because it is a multiple of 2

Note that this is different that the traditional Extended hamming(8,4) code format. I will explain this further. The hamming(8,4) encoded byte is usually generated by a generator matrix, the specific location of the single bit flip is generated using a parity-check matrix. The matrices that I used for this project was borrowed from  Asecuritysite hamming code calculator[2]. I used it because it gave me a convenient way to debug the code, and an easy way to read the data bits. However, the website's generator matrix also resulted in a slightly modifed version of the Hamming code format. 

The reason why I chose this format was because:
- It is simple compares other Hamming Code format
- Allows for some bit flip correction.
- More efficient than storing 3 version of the message. 

There is a few weakness to the program: 
- The encoded message is twice as large as the original.
- It can detect all single bit flip cases, but a few multi bit flips cases can still go undetected. 

Further visualisation of how the Hamming Code works can be found in
a 3Blue1Brown video "But what are Hamming codes? The origin of error correction"[1].


## Implementation and Storage
I stored the encoded message at the end of the image after the IEND chunk.
I specifically referenced the PNG file structure from libpng.org for how data is
stored in a PNG image [3]. 
Each character of the message is split into two parts, encoded in the Hamming code
format, then both are pushed into a short and the shorts together is written down 
on the image. 

To read the message from the image, I scan the image from the end for 
the IEND chunk and see if there is an message down there. It then decode
the message, adding correction when needed and print it out. 




### Glossary:
[0] Hamming(7,4)
- https://en.wikipedia.org/wiki/Hamming(7,4)
[1] 3Blue1Brow: But what are Hamming codes? The origin of error correction
- https://www.youtube.com/watch?v=X8jsijhllIA&t=5s
[2] Asecuritysite hamming code calculator
- https://asecuritysite.com/calculators/hamming
[3] libpng PNG file structure
- http://www.libpng.org/pub/png/spec/1.2/PNG-Structure.html